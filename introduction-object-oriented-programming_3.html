
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="True" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="index, follow" name="robots"/>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&amp;family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&amp;display=swap" rel="stylesheet"/>
<link href="https://ycc.idv.tw/theme/stylesheet/style.less" rel="stylesheet/less" type="text/css"/>
<script src="//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js" type="text/javascript"></script>
<link href="https://ycc.idv.tw/theme/pygments/default.min.css" id="pygments-light-theme" rel="stylesheet" type="text/css"/>
<link href="https://ycc.idv.tw/theme/stork/stork.css" rel="stylesheet" type="text/css">
<link href="https://ycc.idv.tw/theme/font-awesome/css/fontawesome.css" rel="stylesheet" type="text/css"/>
<link href="https://ycc.idv.tw/theme/font-awesome/css/brands.css" rel="stylesheet" type="text/css"/>
<link href="https://ycc.idv.tw/theme/font-awesome/css/solid.css" rel="stylesheet" type="text/css"/>
<link href="/images/favicon.png" rel="shortcut icon" type="image/x-icon"/>
<link href="/images/favicon.png" rel="icon" type="image/x-icon"/>
<!-- Chrome, Firefox OS and Opera -->
<meta content="#FFFFFF" name="theme-color"/>
<!-- Windows Phone -->
<meta content="#FFFFFF" name="msapplication-navbutton-color"/>
<!-- iOS Safari -->
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<!-- Microsoft EDGE -->
<meta content="#FFFFFF" name="msapplication-TileColor"/>
<link href="https://ycc.idv.tw/feeds/all.atom.xml" rel="alternate" title="YC Note Atom" type="application/atom+xml"/>
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68393177-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LXDD9FZFX2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LXDD9FZFX2');
</script>
<meta content="YC Chen" name="author">
<meta content="物件導向怎麼用才能成就好的程式碼？ / UML類別圖 / 單一職責原則(Single Responsibility Principle, SRP) / 開閉原則(Open-Closed Principle, OCP) / 里氏替換原則(Liskov Subsititution Principle, LSP) / 迪米特法則(Law of Demeter, LoD) / 依賴倒置原則(Dependence Inversion Principle, DIP) / 接口分隔原則(Interface Segregation Principle, ISP)" name="description">
<meta content="軟體設計" name="keywords"/>
<meta content="YC Note" property="og:site_name">
<meta content="物件導向武功秘笈（3）：內功篇 — 物件導向指導原則SOLID" property="og:title">
<meta content="物件導向怎麼用才能成就好的程式碼？ / UML類別圖 / 單一職責原則(Single Responsibility Principle, SRP) / 開閉原則(Open-Closed Principle, OCP) / 里氏替換原則(Liskov Subsititution Principle, LSP) / 迪米特法則(Law of Demeter, LoD) / 依賴倒置原則(Dependence Inversion Principle, DIP) / 接口分隔原則(Interface Segregation Principle, ISP)" property="og:description">
<meta content="en_US" property="og:locale">
<meta content="https://ycc.idv.tw/introduction-object-oriented-programming_3.html" property="og:url"/>
<meta content="article" property="og:type"/>
<meta content="2018-04-14 12:00:00+08:00" property="article:published_time"/>
<meta content="" property="article:modified_time"/>
<meta content="https://ycc.idv.tw/author/yc-chen.html" property="article:author"/>
<meta content="CS" property="article:section">
<meta content="軟體設計" property="article:tag"/>
<meta content="" property="og:image"/>
<title>YC Note – 物件導向武功秘笈（3）：內功篇 — 物件導向指導原則SOLID</title>
</meta></meta></meta></meta></meta></meta></meta></link><link href="https://ycc.idv.tw/introduction-object-oriented-programming_3.html" rel="canonical"/><script type="application/ld+json">{"@context": "https://schema.org", "@type": "BreadcrumbList", "itemListElement": [{"@type": "ListItem", "position": 1, "name": "YC Note", "item": "https://ycc.idv.tw"}, {"@type": "ListItem", "position": 2, "name": "Introduction object oriented programming_3", "item": "https://ycc.idv.tw/introduction-object-oriented-programming_3.html"}]}</script><script type="application/ld+json">{"@context": "https://schema.org", "@type": "Article", "author": {"@type": "Person", "name": "YC Chen"}, "publisher": {"@type": "Organization", "name": "YC Note"}, "headline": "物件導向武功秘笈（3）：內功篇 — 物件導向指導原則SOLID", "about": "CS", "datePublished": "2018-04-14 12:00"}</script></head>
<body class="light-theme">
<aside>
<div>
<a href="https://ycc.idv.tw/">
<img alt="YC Note" src="https://ycc.idv.tw/theme/img/profile.png" title="YC Note"/>
</a>
<h1>
<a href="https://ycc.idv.tw/">YC Note</a>
</h1>
<p style="text-align: center;">ML/DL Tech Blog (Total Views: 0) </p>
<div class="stork">
<input autocomplete="off" class="stork-input" data-stork="sitesearch" name="q" onclick="loadStorkIndex(this); this.onclick=null;" placeholder="Search (beta feature) ..." type="text"/>
<div class="stork-output" data-stork="sitesearch-output"></div>
</div>
<!-- <script>
      window.addEventListener('load', 
        function() { 
          loadStorkIndex();
        }, false);
    </script> -->
<p>Hello, I am YC, an ML engineer/researcher with experience in CV, NLP/NLU, and Recommender. I also have experience in high-QPS ML systems. In my spare time, I'm a blogger and guitar singer. <a href="https://ycc.idv.tw/about-me.html#anchor" style="color:yellow">More about me.</a></p>
<p>This blog is a resource for anyone interested in data science and machine learning, featuring tutorials, research papers, and the latest industry technologies.</p>
<ul class="social">
<li>
<a class="sc-facebook" href="https://www.facebook.com/yc.note" target="_blank">
<i class="fa-brands fa-facebook"></i>
</a>
</li>
<li>
<a class="sc-github" href="https://github.com/GitYCC" target="_blank">
<i class="fa-brands fa-github"></i>
</a>
</li>
<li>
<a class="sc-linkedin" href="https://www.linkedin.com/in/yi-chang-chen-aba1b6114/" target="_blank">
<i class="fa-brands fa-linkedin"></i>
</a>
</li>
</ul>
</div>
</aside>
<main>
<nav id="anchor">
<a href="https://ycc.idv.tw/">Home</a>
<a href="/about-me.html#anchor">About Me</a>
<a href="/category/aiml.html#anchor">AI.ML</a>
<a href="/category/cs.html#anchor">CS</a>
<a href="/categories.html#anchor">Categories</a>
<a href="/tags.html#anchor">Tags</a>
<a href="https://ycc.idv.tw/feeds/all.atom.xml">Atom</a>
</nav>
<article class="single">
<header>
<h1 id="introduction-object-oriented-programming_3">物件導向武功秘笈（3）：內功篇 — 物件導向指導原則SOLID</h1>
<p>
      Posted on April 14, 2018 in <a href="https://ycc.idv.tw/category/cs.html">CS</a>. View: 0

    </p>
</header>
<div class="tag-cloud">
<p>
<a href="https://ycc.idv.tw/tag/ruan-ti-she-ji.html">軟體設計</a>
</p>
</div>
<div class="main-contents">
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">物件導向怎麼用才能成就好的程式碼？</a></li>
<li><a href="#uml">UML類別圖</a></li>
<li><a href="#single-responsibility-principle-srp">單一職責原則(Single Responsibility Principle, SRP)</a></li>
<li><a href="#open-closed-principle-ocp">開閉原則(Open-Closed Principle, OCP)</a></li>
<li><a href="#liskov-subsititution-principle-lsp">里氏替換原則(Liskov Subsititution Principle, LSP)</a></li>
<li><a href="#law-of-demeter-lod">迪米特法則(Law of Demeter, LoD)</a></li>
<li><a href="#dependence-inversion-principle-dip">依賴倒置原則(Dependence Inversion Principle, DIP)</a></li>
<li><a href="#interface-segregation-principle-isp">接口分隔原則(Interface Segregation Principle, ISP)</a></li>
<li><a href="#solid">總結：物件導向的指導原則—SOLID</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
</div>
<h3 id="_1">物件導向怎麼用才能成就好的程式碼？</h3>
<p>一個好的工具，也要配合對於工具的理解，才能發揮效用。<a href="/introduction-object-oriented-programming_2.html">在上一回中</a>，我們完整介紹了Java和Python的物件導向實現方式，我們講到了「封裝」、「繼承」、「多型」等等物件導向的特色，也講了「抽象類別」、「接口」等抽象化的方法，不過我並沒有告訴大家該怎麼用這些工具？使用這些工具是不是有什麼樣的法則？</p>
<p>在接下來的這一篇，我將會介紹物件導向的使用方式，我會提到物件導向著名的六大法則SOLID：</p>
<ol>
<li>單一職責原理</li>
<li>開閉原理</li>
<li>里氏替換原則</li>
<li>迪米特法則</li>
<li>依賴倒置原則</li>
<li>接口分隔原則</li>
</ol>
<p>在這之前我們先來介紹描述類別關係的UML類別圖。</p>
<h3 id="uml">UML類別圖</h3>
<p>開始介紹各種原則之前，先來介紹UML類別圖，UML全名稱為Unified Modeling Language，是一種使用圖形來描繪軟體工程架構的方法，這邊準備介紹的是它的類別圖，這個工具有助於我們快速的了解物件與物件之間的關係。</p>
<p>首先先來看一下UML類別圖的節點，共有三種：</p>
<ul>
<li>類別(Class): 其中第一個 block 表示名稱、第二個 block 表示變數、第三個 block 表示方法。而 <code>-</code> 代表 <code>private</code>，<code>+</code> 代表<code>public</code>，<code>#</code> 代表<code>protected</code></li>
</ul>
<p><img alt="Class" src="/media/SOLID_Introduction/Class.png"/></p>
<ul>
<li>抽象類別(Abstract Class)</li>
</ul>
<p><img alt="AbstractClass" src="/media/SOLID_Introduction/AbstractClass.png"/></p>
<ul>
<li>接口(Interface)</li>
</ul>
<p><img alt="Interface" src="/media/SOLID_Introduction/Interface.png"/></p>
<p>接下來來了解UML類別圖的連接關係，從連接關係的強到弱依序介紹：</p>
<ul>
<li>繼承關係(Inheritance)和抽象類、接口實現：在UML類別圖中，箭頭方向代表依賴方向，A箭頭指向B，代表A依賴B，代表B的改變將連同改變A，而A的改變不影響B。因此在繼承關係中，子類箭頭指向父類，意味著子類依賴父類。</li>
</ul>
<p><img alt="Inheritance" src="/media/SOLID_Introduction/Inheritance.png"/></p>
<ul>
<li>合成（組合）關係(Composition)：指的是 "is-part-of" 的關係，是一個強的「擁有」關係。實心菱形指向整體、箭頭指向部件（代表整體依賴部件），整體不可以脫離部件而存在，例如下面範例中飛機不能沒有引擎。在程式碼中，通常部件會放在「成員變數」中，並且在實例化時就產生。</li>
</ul>
<p><img alt="Composition" src="/media/SOLID_Introduction/Composition.png"/></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">PlaneEngine</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Plane</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span> <span class="o">=</span> <span class="n">PlaneEngine</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>聚合關係(Aggregation)：指的是 "owns-a" 的關係，是一個弱的「擁有」關係。空心菱形指向整體、箭頭指向部件（代表整體依賴部件），整體可以脫離部件而存在，整體和部件擁有各自的生命週期，例如下面範例中飛機場有停放飛機，但是除去飛機，飛機場仍可以正常運作。在程式碼中，通常部件會放在「成員變數」中。</li>
</ul>
<p><img alt="Aggregation" src="/media/SOLID_Introduction/Aggregation.png"/></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Plane</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Airport</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_planes</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>關聯關係(Association)：指的是 "has-a" 的關係，是個「有個」的關係。兩種類別擁有各自的生命週期，且兩者並不具備整體與部件的關係，我們使用 Association 來連接，箭頭代表依賴的方向，例如下面範例中飛機和排程不具有整體與部件的關係，但飛機有個排程。在程式碼中，會放在「成員變數」中。</li>
</ul>
<p><img alt="Associatione" src="/media/SOLID_Introduction/Association.png"/></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Schedule</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Plane</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schedule</span> <span class="o">=</span> <span class="n">Schedule</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>依賴關係(Dependency)：指的是 "uses-a" 的關係，是個「使用」的關係。A類中使用到B類，但僅僅是弱連結（在程式碼中，不放在「成員變數」中），譬如：B類作為A類方法的參數、B類作為A類的局域變數、A類調用B類的靜態方法、B類作為A類方法的回傳值，就稱為：A依賴B。</li>
</ul>
<p><img alt="Dependency" src="/media/SOLID_Introduction/Dependency.png"/></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Plane</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">PlanePilot</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pilot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
<h3 id="single-responsibility-principle-srp">單一職責原則(Single Responsibility Principle, SRP)</h3>
<ul>
<li>
<p>定義：There should never be more than one reason for a class to change.（一個類別中不要有多於一個以上的變化理由）</p>
</li>
<li>
<p>簡單的說，就是一個類別中不要做超過一件事，要去切分直到不能再分割為止，如此一來可以提高內聚性。</p>
</li>
<li>
<p>乍看之下，這樣的原則很容易實現，但是魔鬼藏在細節裡，我們常常會沒注意到其實還可以繼續的切分。舉個例子，假設我想設計一個電話的接口，我可能是這樣設計的</p>
</li>
</ul>
<p><img alt="phone_1" src="/media/SOLID_Introduction/phone_1.png"/></p>
<p>乍看之下沒有問題，一個電話擁有撥號、掛號、數據傳送和接收，但是等等！連接的過程和數據的傳輸其實是兩個職責啊！它們之間沒有強烈的關聯性，完全是可以分開處理的，因此這個配置不符合「單一職責原則」，可以繼續切分下去，修改如下。</p>
<p><img alt="phone_2" src="/media/SOLID_Introduction/phone_2.png"/></p>
<ul>
<li>「單一職責原則」原文指的是類別的單一職責，但是務實上，類別如果切分到如此程度，程式碼會變得細碎不堪，這違反了程式碼的「可讀性」，所以我們一般只要求「接口必須保持單一原則」，而類別去套用接口，類別就盡量達成少的職責就好。</li>
</ul>
<h3 id="open-closed-principle-ocp">開閉原則(Open-Closed Principle, OCP)</h3>
<ul>
<li>
<p>定義：Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.（軟體中的實體，例如：類、模組、函數等等，都必須對延伸開放，但對修改封閉）</p>
</li>
<li>
<p>對延伸開放：實體在因應新的改變時，必須是可以靈活擴充的。</p>
</li>
<li>
<p>對修改封閉：實體一旦完成，就盡量不要再去修改它了。</p>
</li>
<li>
<p>綜合以上兩點，我們可以總結出：實體本身的內聚性要高，可以讓我們未來不需要再做修改，單一職責可以做到增強內聚性；實體間的耦合性要低，所以實體像是積木一樣可以因應各種需求去任意組合、擴充。所以「開閉原則」只是進一步的把「低耦合高內聚」再說的更清楚一點，實現「開閉原則」將有利於單元測試、提高維護和擴充能力。</p>
</li>
</ul>
<h3 id="liskov-subsititution-principle-lsp">里氏替換原則(Liskov Subsititution Principle, LSP)</h3>
<ul>
<li>
<p>定義：What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（簡言之：子類對象能夠替換其父類對象，使用父類方法而不會有問題）</p>
</li>
<li>
<p>「里氏替換原則」用於規範繼承，子類繼承自父類的方法是保有彈性可以覆寫(Overriding)和多載(Overloading)的，但是應該怎麼做，程式碼才不會髒掉？「里氏替換原則」告訴我們一個簡單的法則，就是先寫一段父類的執行代碼，然後把父類替換成子類，然後再跑跑看能不能正常執行，如果正常執行代表這個繼承關係是健康的。</p>
</li>
<li>
<p>為什麼要這樣檢查？之前我們提過繼承主要是為了要避免Repeat Yourself而生，我們找出各種類別共享的屬性和方法，把它獨立出來，然後大家再一起繼承自它，所以我們要盡可能的避免父類出現不是共享的性質。也就是說在理想情況下「父類必須等於子類們的交集」，所以「父類必定是任一子類的子集合」，因此「使用子類來執行父類是不應該有問題的」，這就是「里氏替換原則」。</p>
</li>
<li>
<p>為了遵循「里氏替換原則」，則子類必須完全實現父類的方法。如果子類不能完整地實現父類的方法，或者父類的某些方法在子類中已經發生了「畸變」，則建議斷開父子繼承關係，採用依賴、聚集、組合等關係替代。</p>
</li>
<li>
<p>有了「里氏替換原則」，我們終於可以談談一個上一章沒提到的重要問題：什麼情況可以做繼承？有一些書籍會告訴你，繼承為"is-a"的關係，例如：瑪爾濟斯(B) is-a 狗(A)，所以瑪爾濟斯(B)可以繼承狗(A)，乍看之下沒問題，但這樣的說法存在缺陷，舉個例子，假設今天我先有了類別<code>Retangle</code>，也就是長方形，然後我想要弄一個新的類別<code>Square</code>，也就是正方形，我可以讓<code>Square</code>繼承自<code>Retangle</code>嗎？我們用"is-a"來檢視：正方形是一個長方形？答案是Yes，但是「里氏替換原則」持相反意見，來看一下，</p>
</li>
</ul>
<p><img alt="square_1" src="/media/SOLID_Introduction/square_1.png"/></p>
<p>依照「里氏替換原則」，<code>Square</code>不能繼承自<code>Retangle</code>，因為<code>Square</code>只需要<code>width</code>的成員變數，而<code>Retangle</code>則需要<code>width</code>和<code>height</code>兩個成員變數，當我們將子類<code>Square</code>放到父類<code>Retangle</code>的方法中，因為缺少<code>height</code>變數，必然會出錯，所以違反「里氏替換原則」，因此這兩類不適合作為「繼承」關係。我們可以這樣改善，讓<code>Square</code>應用<code>Retangle</code>來幫忙計算，使用「關聯」關係取代「繼承」關係。</p>
<p><img alt="square_2" src="/media/SOLID_Introduction/square_2.png"/></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Retangle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">=</span> <span class="n">height</span>

    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height</span>

<span class="k">class</span> <span class="nc">Square</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_retangle</span> <span class="o">=</span> <span class="n">Retangle</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retangle</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>下面這一張集合圖是我自創的，圖中清楚的指出「繼承」中的父類和子類應該是什麼樣的關係。</li>
</ul>
<p><img alt="Inheritance Principle.jpeg" src="/media/SOLID_Introduction/inheritance_principle.jpeg"/></p>
<h3 id="law-of-demeter-lod">迪米特法則(Law of Demeter, LoD)</h3>
<p>又稱為「最少知識原則」，它規定物件應該要對其他物件有最少的了解。</p>
<p><strong>規則1：一個物件應該與它「朋友」互動，而不應該與陌生對象互動。</strong>這樣可以減少耦合，提高物件之間的低耦合性，使得物件與物件之間的關係更加簡單易懂。「朋友」的定義：對於類別 C 的其中一個方法 M 而言，在 M 的方法中僅能訪問以下物件：  </p>
<ul>
<li><code>self</code>，類別 C 自身</li>
<li>C 的成員變數</li>
<li>M 的輸入參數</li>
<li>M 的輸出物件</li>
<li>全域變數的物件</li>
</ul>
<p>舉個例子：假設今天一名老師給了學生名條想叫班長幫忙點名</p>
<p>錯誤示範：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">class</span> <span class="nc">Leader</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countStudents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">student_list</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Total number of students is "</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">student_list</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Teacher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_list</span><span class="p">,</span> <span class="n">leader</span><span class="p">):</span>
        <span class="n">student_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Student</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">name_list</span><span class="p">]</span>  <span class="c1"># `Student` is not a friend</span>
        <span class="n">leader</span><span class="o">.</span><span class="n">countStudents</span><span class="p">(</span><span class="n">student_list</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">teacher</span> <span class="o">=</span> <span class="n">Teacher</span><span class="p">()</span>
    <span class="n">leader</span> <span class="o">=</span> <span class="n">Leader</span><span class="p">()</span>
    <span class="n">name_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">,</span> <span class="s1">'E'</span><span class="p">]</span>
    <span class="n">teacher</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="n">name_list</span><span class="p">,</span> <span class="n">leader</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<p><img alt="teacher-leader-student_1" src="/media/SOLID_Introduction/teacher-leader-student_1.png"/></p>
<p>我們來使用「迪米特法則」來檢驗一下，<code>Teacher.command</code> 的「朋友」有 <code>self</code>、輸入參數 <code>name_list</code> (<code>List[String]</code>) 和 <code>leader</code> (<code>Leader</code>)，但在上面這個例子它使用到了不是「朋友」的 <code>Student</code>，這會使得 <code>Teacher</code> 和 <code>Student</code> 會產生不必要的耦合。解法是，我們可以將創造 <code>student_list</code> 的權責轉移到 <code>Leader</code> 上，如此一來就可以斷開 <code>Teacher</code> 和 <code>Student</code> 的耦合。</p>
<p>正確示範：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">class</span> <span class="nc">Leader</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">giveNameList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_student_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Student</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">name_list</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">countStudents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Total number of students is "</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_student_list</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Teacher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_list</span><span class="p">,</span> <span class="n">leader</span><span class="p">):</span>
        <span class="n">leader</span><span class="o">.</span><span class="n">giveNameList</span><span class="p">(</span><span class="n">name_list</span><span class="p">)</span>
        <span class="n">leader</span><span class="o">.</span><span class="n">countStudents</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">teacher</span> <span class="o">=</span> <span class="n">Teacher</span><span class="p">()</span>
    <span class="n">leader</span> <span class="o">=</span> <span class="n">Leader</span><span class="p">()</span>
    <span class="n">name_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">,</span> <span class="s1">'E'</span><span class="p">]</span>
    <span class="n">teacher</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="n">name_list</span><span class="p">,</span> <span class="n">leader</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<p><img alt="teacher-leader-student_2" src="/media/SOLID_Introduction/teacher-leader-student_2.png"/></p>
<p>為什麼這樣規範呢？先來想想「朋友」有什麼共通之處，其實它們都是類別本身無法斷開耦合的物件，既然無法斷開耦合，何不運用到底，運用這些「朋友」來完成任務，不要再去增加其他的耦合性，也同時幫助提升類別的內聚性，這就是「迪米特法則」想做的事。以這樣的方式去寫程式，也可以避免寫出像是<code>A.getB().getC()</code>的程式碼（A和C不是朋友），這樣冗長的程式碼不僅增加了無益的耦合，也讓程式變得不利於可讀性。</p>
<p><strong>規則2：減少類別的對外方法，將沒必要對外公布的方法隱藏起來。</strong></p>
<p>例子: 安裝程式。</p>
<p>錯誤範例：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Wizard</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Install first step of wizard at mode"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Install second step of wizard at mode "</span> <span class="o">+</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">third</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Install third step of wizard"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Install</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wizard</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="n">wizard</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="n">wizard</span><span class="o">.</span><span class="n">second</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">wizard</span><span class="o">.</span><span class="n">third</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
<p>有太多沒必要對外公布的細節了，依照「迪米特法則」，我們應該將盡量減少對外公布的資訊，把不必要公布的細節私有化。</p>
<p>正確範例：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Wizard</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_third</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Install first step of wizard"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_second</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Install second step of wizard at mode "</span> <span class="o">+</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_third</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Install third step of wizard"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Install</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wizard</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="n">wizard</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<h3 id="dependence-inversion-principle-dip">依賴倒置原則(Dependence Inversion Principle, DIP)</h3>
<ul>
<li>定義：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.（高階模組不應該依賴低階模組，兩者都應該依賴抽象。而抽象不應該依賴細節，反之細節應該要依賴抽象。）</li>
<li>它要求高階模組不應該依賴低階模組，而是應該依賴抽象。這意味著在設計類之間的關係時，應該避免直接依賴具體類，而是應該依賴抽象類。這樣可以使得高階模組不受低階模組的影響，並且可以更容易地更換和修改低階模組。依賴倒置原則可以通過使用介面和抽象類來實現。</li>
<li>舉個例子，假設我們有一個高階模組，它負責讀取和顯示數據。我們有一個低階模組，它負責從文件中讀取數據。如果高階模組直接依賴低階模組，那麼如果低階模組的實現發生變化，高階模組也必須作出相應的修改。這樣不符合依賴倒置原則，我們應該抽象出一個抽象類，讓高階模組依賴於這個抽象類，而低階模組實現這個抽象類。</li>
</ul>
<p><img alt="" src="/media/SOLID_Introduction/dip.png"/></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">DataReader</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<span class="k">class</span> <span class="nc">CsvDataReader</span><span class="p">(</span><span class="n">DataReader</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># code to read data from csv</span>
        <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">HighLevelModule</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_reader</span><span class="p">:</span> <span class="n">DataReader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_reader</span> <span class="o">=</span> <span class="n">data_reader</span>

    <span class="k">def</span> <span class="nf">read_and_display_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_reader</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">file_data_reader</span> <span class="o">=</span> <span class="n">CsvDataReader</span><span class="p">()</span>
    <span class="n">high_level_module</span> <span class="o">=</span> <span class="n">HighLevelModule</span><span class="p">(</span><span class="n">file_data_reader</span><span class="p">)</span>
    <span class="n">high_level_module</span><span class="o">.</span><span class="n">read_and_display_data</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
<p>在上面程式碼中，<code>DataReader</code>是一個抽象類，它定義了一個<code>read_data()</code>方法。<code>CsvDataReader</code>是一個具體類，它實現了<code>DataReader</code>並從文件中讀取數據。<code>HighLevelModule</code>是一個高階模組，它依賴於<code>DataReader</code>接口而不是具體類。這樣，當低階模組的實現發生變化時，高階模組不需要作出任何修改，只需要更換實現了<code>DataReader</code>抽象類的具體類即可。這樣可以使得高階模組更穩定，並且可以更容易地更換和修改低階模組。同時，由於高階模組依賴的是抽象類，而不是具體類，我們可以更輕鬆地對高階模組進行測試，因為我們可以使用模擬數據來模擬低階模組的行為。</p>
<ul>
<li>依賴倒置原則又稱為「面向接口原則」，這裡的接口應該想的更廣義一點，不侷限在interface上，我認為只要藉由抽象化將架構擬定出來的這些抽象單元都可以稱作接口，「廣義的接口」可以是指：<ol>
<li>客戶端和業務邏輯的分離介面</li>
<li>物件的開放方法</li>
<li>抽象類別</li>
<li>定義行為的interface</li>
</ol>
</li>
</ul>
<h3 id="interface-segregation-principle-isp">接口分隔原則(Interface Segregation Principle, ISP)</h3>
<ul>
<li>定義：Clients should not be forced to depend uponn interfaces that they don't use. The dependency of one class to another one should depend on the smallest possible interface.（客戶類不應該被強迫依賴那些它不需要的接口，類別間的彼此依賴應該建立在盡可能小的接口上）</li>
<li>這裡說的接口同樣的是剛剛所說的「廣義接口」，可以是客戶端和業務邏輯的分離介面、物件的開放方法、抽象類別和Interface。</li>
<li>它要求將較大的接口分解成較小的接口，以適應客戶端需求。這樣做可以避免客戶端被迫使實現未使用的方法，並減少程序的耦合性。接口分隔原則建議我們要讓這些廣義接口盡可能的細切，但在實務上，切的過細會導致程式碼非常零碎難以閱讀，所以YC的建議是切到遵守「單一職責原理」就足夠了。</li>
<li>舉個例子：錯誤範例如下</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Document</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<span class="k">class</span> <span class="nc">SimpleDocument</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document opened"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document closed"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document saved"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ComplexDocument</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document opened"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document closed"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document saved"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document encrypted"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document decrypted"</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<p>上述程式碼中，<code>SimpleDocument</code> 類可能只需要繼承中的一部分方法，這樣的設計違反了 ISP 原則，客戶端 (<code>SimpleDocument</code> 和 <code>ComplexDocument</code> 類) 被迫使實現未使用的方法。更好的設計方法是將這些方法分為兩個不同的接口，例如 <code>DocumentHandler</code> 和 <code>DocumentEncoder</code>，並讓客戶端只實現需要的接口。修改如下：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">DocumentHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<span class="k">class</span> <span class="nc">DocumentEncoder</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<span class="k">class</span> <span class="nc">SimpleDocument</span><span class="p">(</span><span class="n">DocumentHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document opened"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document closed"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document saved"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ComplexDocument</span><span class="p">(</span><span class="n">DocumentHandler</span><span class="p">,</span> <span class="n">DocumentEncoder</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document opened"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document closed"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document saved"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document encrypted"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Document decrypted"</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<p><img alt="" src="/media/SOLID_Introduction/isp.png"/></p>
<p>這樣的設計更符合 ISP 原則，因為客戶端 (<code>SimpleDocument</code> 和 <code>ComplexDocument</code> 類) 只實現了需要的接口，並沒有被迫使實現未使用的方法。這樣可以減少程序的耦合性，並更容易維護和擴展。</p>
<h3 id="solid">總結：物件導向的指導原則—SOLID</h3>
<p>上面介紹的六大原理：</p>
<ol>
<li>Single Responsibility Principl</li>
<li>Open-Closed Principle</li>
<li>Liskov Subsititution Principle</li>
<li>Law of Demeter</li>
<li>Interface Segregation Principle</li>
<li>Dependence Inversion Principle</li>
</ol>
<p>剛剛好組成SOLID這個單字，所以又被統稱SOLID原則。</p>
<p>事實上，這些原則所要達到的目的，不外乎就是我們<a href="/introduction-object-oriented-programming_1.html">第一篇</a>當中所介紹的好的程式碼特性：「正常執行」、「穩健」、「不重複撰寫」、「可讀性」、「可擴展」，或者是「低耦合、高內聚」，所以寫程式時如果能時時注意，說不定你也可以自己領會這六大法則。</p>
<p>我來快速的總結這六大法則告訴我們的事：</p>
<ol>
<li><strong>在開發程式的初期，先定義好抽象架構，也就是廣義的接口，徹底的使客戶端與業務邏輯分離，將「行為」定義成Interface，將「類別的泛化」定義成Abstract Class。</strong></li>
<li><strong>所有的實體類別都依賴於抽象，細節依賴於抽象。</strong></li>
<li><strong>每個單元盡量達到：單一權責、對延伸開放但對修改封閉、盡可能少的對外方法。</strong></li>
<li><strong>牽涉「繼承」，必須要問自己：子類可以替換父類執行嗎？父類是不是為子類的交集？</strong></li>
<li><strong>類別中的方法僅能訪問它的「朋友」們。</strong></li>
</ol>
<p>如此一來，我們心中就有一個準則去使用物件導向。</p>
<p>在一般情形下，這三篇的內容應該就足夠讓你寫出好的程式碼，但是實際面上使用仍然會碰到許多問題，於是乎有人將問題整理並總結出一些套路，這就是「設計模式」，我們以後再來談談吧！今天就先到這。</p>
<h3 id="reference">Reference</h3>
<ol>
<li><a href="https://www.tenlong.com.tw/products/9789866761799">大話設計模式</a></li>
<li><a href="https://www.tenlong.com.tw/products/9787111437871">設計模式之禪</a></li>
<li>use <a href="https://plantuml.com">plantuml</a> in hackmd</li>
</ol>
</div>
<div class="center social-share">
<p>Like this article? Share it with your friends!</p>
<div class="addthis_native_toolbox"></div>
<div class="addthis_sharing_toolbox"></div>
<div class="addthis_inline_share_toolbox"></div>
</div>
<div class="neighbors">
<a class="btn float-left" href="https://ycc.idv.tw/introduction-object-oriented-programming_2.html#anchor" title="物件導向武功秘笈（2）：招式篇 — Python與Java的物件導向編程介紹">
<i class="fa fa-angle-left"></i> Previous Post
    </a>
<a class="btn float-right" href="https://ycc.idv.tw/sweet-child-oh-mine.html#anchor" title="尾牙表演 - Sweet Child Oh Mine">
      Next Post <i class="fa fa-angle-right"></i>
</a>
</div>
<div class="addthis_relatedposts_inline"></div>
<div class="related-posts">
<h4>Part 3 of the "物件導向武功秘笈" series</h4>
<h5>Previous articles</h5>
<ul>
<li><a href="https://ycc.idv.tw/introduction-object-oriented-programming_1.html#anchor">物件導向武功秘笈（1）：認知篇 — 什麼是好的程式？</a></li>
<li><a href="https://ycc.idv.tw/introduction-object-oriented-programming_2.html#anchor">物件導向武功秘笈（2）：招式篇 — Python與Java的物件導向編程介紹</a></li>
</ul>
</div>
<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ycnote-1';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>
<footer>
<p>
  © 2024  - This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" rel="license" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><p>
<a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license" target="_blank">
<img alt="Creative Commons License" height="15" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" style="border-width:0" title="Creative Commons License" width="80"/>
</a>
</p></footer> </main>
<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " YC Note ",
  "url" : "https://ycc.idv.tw",
  "image": "",
  "description": "[ YC Note - ML/DL Tech Blog ] Hello, I am YC, an ML engineer/researcher with experience in CV, NLP/NLU, and Recommender. I built this blog for anyone interested in data science and machine learning."
}
</script><script async="async" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-63b4eabb5e84e9fb" type="text/javascript"></script>
<script>
    window.loadStorkIndex = async (input_obj) => {
      input_obj.disabled = true;
      input_obj.placeholder = 'Downloading index file, please wait ...'
      await stork.register("sitesearch", "https://ycc.idv.tw/search-index.st", { showProgress: false });
      input_obj.placeholder = 'Search ...'
      input_obj.disabled = false;
    }
  </script>
<script src="https://files.stork-search.net/releases/v1.5.0/stork.js"></script>
</body>
</html>